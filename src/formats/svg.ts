import { RemoveOptions } from '../types.js';
import { SvgParseError } from '../errors.js';

/**
 * Editor-specific namespace prefixes to remove
 */
const EDITOR_NAMESPACES = [
  'inkscape:',
  'sodipodi:',
  'illustrator:',
  'sketch:',
  'serif:',
  'vectornator:',
  'figma:',
  'adobe:',
  'xd:',
  'photoshop:',
  'corel:',
  'dc:', // Dublin Core
  'cc:', // Creative Commons
  'rdf:', // RDF
];

/**
 * Namespace URIs to remove from xmlns declarations
 */
const NAMESPACE_URIS_TO_REMOVE = [
  'http://www.inkscape.org',
  'http://sodipodi.sourceforge.net',
  'http://ns.adobe.com/Illustrator',
  'http://www.w3.org/1999/02/22-rdf-syntax-ns',
  'http://purl.org/dc/elements',
  'http://creativecommons.org/ns',
  'http://www.bohemiancoding.com/sketch/ns',
];

/**
 * Parse SVG as text
 */
function parseSvg(data: Uint8Array): string {
  // Decode as UTF-8
  const decoder = new TextDecoder('utf-8');
  let svgText = decoder.decode(data);

  // Remove BOM if present
  if (svgText.charCodeAt(0) === 0xfeff) {
    svgText = svgText.slice(1);
  }

  // Validate it looks like SVG
  const trimmed = svgText.trim().toLowerCase();
  if (!trimmed.startsWith('<?xml') && !trimmed.startsWith('<svg')) {
    throw new SvgParseError('Not a valid SVG document');
  }

  if (!trimmed.includes('<svg')) {
    throw new SvgParseError('Missing <svg> element');
  }

  return svgText;
}

/**
 * Remove XML comments
 */
function removeComments(svgText: string): string {
  // Remove XML comments <!-- ... -->
  return svgText.replace(/<!--[\s\S]*?-->/g, '');
}

/**
 * Remove processing instructions (except XML declaration)
 */
function removeProcessingInstructions(svgText: string): string {
  // Keep XML declaration, remove others
  return svgText.replace(/<\?(?!xml[\s?])[\s\S]*?\?>/gi, '');
}

/**
 * Remove metadata elements
 */
function removeMetadataElements(svgText: string, options: RemoveOptions): string {
  let result = svgText;

  // Remove <metadata>...</metadata>
  result = result.replace(/<metadata[\s\S]*?<\/metadata>/gi, '');

  // Remove self-closing metadata
  result = result.replace(/<metadata[^>]*\/>/gi, '');

  // Remove RDF elements
  result = result.replace(/<rdf:RDF[\s\S]*?<\/rdf:RDF>/gi, '');

  // Remove title if not preserving
  if (options.preserveTitle !== true) {
    result = result.replace(/<title[\s\S]*?<\/title>/gi, '');
    result = result.replace(/<title[^>]*\/>/gi, '');
  }

  // Remove desc if not preserving
  if (options.preserveDescription !== true) {
    result = result.replace(/<desc[\s\S]*?<\/desc>/gi, '');
    result = result.replace(/<desc[^>]*\/>/gi, '');
  }

  // Remove editor-specific elements
  result = result.replace(/<sodipodi:[\w-]+[\s\S]*?<\/sodipodi:[\w-]+>/gi, '');
  result = result.replace(/<sodipodi:[\w-]+[^>]*\/>/gi, '');

  result = result.replace(/<inkscape:[\w-]+[\s\S]*?<\/inkscape:[\w-]+>/gi, '');
  result = result.replace(/<inkscape:[\w-]+[^>]*\/>/gi, '');

  return result;
}

/**
 * Remove editor-specific attributes from elements
 */
function removeEditorAttributes(svgText: string): string {
  let result = svgText;

  // Remove attributes with editor namespace prefixes
  for (const prefix of EDITOR_NAMESPACES) {
    // Match attributes like inkscape:label="..." or inkscape:label='...'
    const escaped = prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const attrPattern = new RegExp(`\\s+${escaped}[\\w-]+\\s*=\\s*(?:"[^"]*"|'[^']*')`, 'gi');
    result = result.replace(attrPattern, '');
  }

  // Remove xmlns declarations for editor namespaces
  for (const uri of NAMESPACE_URIS_TO_REMOVE) {
    const nsPattern = new RegExp(
      `\\s+xmlns:[\\w-]+\\s*=\\s*["'][^"']*${uri.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}[^"']*["']`,
      'gi'
    );
    result = result.replace(nsPattern, '');
  }

  return result;
}

/**
 * Remove ID attributes that look auto-generated (UUIDs), but only when the ID
 * is not referenced elsewhere in the document (e.g. via url(#id), href="#id",
 * clip-path, mask, fill, filter attributes).
 */
function removeAutoGeneratedIds(svgText: string): string {
  return svgText.replace(
    /\s+id\s*=\s*["']([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})["']/gi,
    (match, id: string) => {
      // Keep the ID if it is referenced anywhere else (url(#id), href="#id", etc.)
      const escaped = id.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const refPattern = new RegExp(`["'(#]${escaped}["')\\s]`);
      if (refPattern.test(svgText)) {
        return match;
      }
      return '';
    }
  );
}

/**
 * Remove data- attributes (often contain metadata)
 */
function removeDataAttributes(svgText: string): string {
  return svgText.replace(/\s+data-[\w-]+\s*=\s*["'][^"']*["']/gi, '');
}

/**
 * Clean up whitespace
 */
function cleanupWhitespace(svgText: string): string {
  // Remove extra blank lines
  let result = svgText.replace(/\n\s*\n\s*\n/g, '\n\n');

  // Remove trailing whitespace on lines
  result = result.replace(/[ \t]+$/gm, '');

  // Trim start and end
  result = result.trim();

  return result;
}

/**
 * Remove metadata from SVG image
 */
export function remove(data: Uint8Array, options: RemoveOptions = {}): Uint8Array {
  let svgText = parseSvg(data);

  // Apply transformations
  svgText = removeComments(svgText);
  svgText = removeProcessingInstructions(svgText);
  svgText = removeMetadataElements(svgText, options);
  svgText = removeEditorAttributes(svgText);
  svgText = removeAutoGeneratedIds(svgText);
  svgText = removeDataAttributes(svgText);
  svgText = cleanupWhitespace(svgText);

  // Encode back to UTF-8
  const encoder = new TextEncoder();
  return encoder.encode(svgText);
}

/**
 * Get list of metadata types present in the image
 */
export function getMetadataTypes(data: Uint8Array): string[] {
  const svgText = parseSvg(data);
  const types: string[] = [];

  if (/<metadata/i.test(svgText)) {
    types.push('Metadata element');
  }

  if (/<rdf:RDF/i.test(svgText)) {
    types.push('RDF metadata');
  }

  if (/<dc:/i.test(svgText)) {
    types.push('Dublin Core');
  }

  if (/<cc:/i.test(svgText)) {
    types.push('Creative Commons');
  }

  if (/inkscape:/i.test(svgText)) {
    types.push('Inkscape metadata');
  }

  if (/sodipodi:/i.test(svgText)) {
    types.push('Sodipodi metadata');
  }

  if (/illustrator:/i.test(svgText)) {
    types.push('Illustrator metadata');
  }

  if (/<!--[\s\S]*?-->/g.test(svgText)) {
    types.push('XML comments');
  }

  if (/<title/i.test(svgText)) {
    types.push('Title');
  }

  if (/<desc/i.test(svgText)) {
    types.push('Description');
  }

  if (/data-[\w-]+\s*=/i.test(svgText)) {
    types.push('Data attributes');
  }

  return [...new Set(types)];
}

import type { MetadataMap } from '../types.js';

/**
 * Read structured metadata from an SVG without modifying it.
 */
export function read(data: Uint8Array): Partial<MetadataMap> {
  const out: Partial<MetadataMap> = {};
  try {
    const text = parseSvg(data);
    const titleMatch = /<title[^>]*>([\s\S]*?)<\/title>/i.exec(text);
    if (titleMatch) {
      out.imageDescription = titleMatch[1]!.trim();
    }
    const descMatch = /<desc[^>]*>([\s\S]*?)<\/desc>/i.exec(text);
    if (descMatch) {
      out.software = descMatch[1]!.trim();
    }
    if (/<metadata/i.test(text) || /rdf:RDF/i.test(text)) {
      out.hasXmp = true;
    }
  } catch {
    /* ignore */
  }
  return out;
}

export const svg = {
  remove,
  getMetadataTypes,
  read,
};

export default svg;
